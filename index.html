<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hacker News Comment Tree Visualizer</title>
    <style>
      * {
        box-sizing: border-box;
      }

      :root {
        --hn-orange: #ff6600;
        --hn-orange-dark: #cc5200;
        --hn-beige: #f6f6ef;
        --hn-beige-dark: #e8e8e0;
        --text-primary: #000;
        --text-secondary: #666;
        --text-muted: #828282;
        --border-color: #ccc;
        --highlight-bg: #ffff00;
        --deleted-bg: #f0f0f0;
        --focus-ring: #ff6600;
        --inactive-opacity: 0.6;
      }

      body {
        font-family: Verdana, Geneva, sans-serif;
        font-size: 13px;
        background-color: var(--hn-beige);
        margin: 0;
        padding: 20px;
        line-height: 1.4;
        color: var(--text-primary);
      }

      h1 {
        color: var(--hn-orange);
        margin: 0 0 20px 0;
        font-size: 18px;
      }

      /* Input Section */
      .input-section {
        background: white;
        border-radius: 4px;
        margin-bottom: 20px;
        border: 1px solid var(--border-color);
      }

      .input-tabs {
        display: flex;
        border-bottom: 1px solid var(--border-color);
      }

      .input-tab {
        padding: 10px 16px;
        font-size: 13px;
        font-weight: 500;
        color: var(--text-muted);
        background: transparent;
        border: none;
        cursor: pointer;
        border-bottom: 2px solid transparent;
        margin-bottom: -1px;
        transition: color 0.15s, border-color 0.15s;
      }

      .input-tab:hover {
        color: var(--text-color);
      }

      .input-tab.active {
        color: var(--hn-orange);
        border-bottom-color: var(--hn-orange);
      }

      .input-tab-content {
        display: none;
        padding: 15px;
      }

      .input-tab-content.active {
        display: block;
      }

      .front-page-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 12px;
        margin-bottom: 8px;
      }

      .front-page-header span {
        font-size: 12px;
        color: var(--text-muted);
      }

      .front-page-refresh {
        font-size: 11px;
        color: var(--text-muted);
        cursor: pointer;
        text-decoration: none;
      }

      .front-page-refresh:hover {
        color: var(--hn-orange);
        text-decoration: underline;
      }

      .front-page-list {
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 280px;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 3px;
      }

      .front-page-item {
        padding: 8px 10px;
        font-size: 12px;
        line-height: 1.4;
      }

      .front-page-item:last-child {
        border-bottom: none;
      }

      .front-page-item:hover {
        /* background: var(--hn-beige-dark); */
      }

      .front-page-title {
        color: var(--text-color);
        cursor: pointer;
        text-decoration: none;
      }

      .front-page-title:hover {
        color: var(--hn-orange);
      }

      .front-page-meta {
        font-size: 11px;
        color: var(--text-muted);
        margin-top: 2px;
      }

      .front-page-loading,
      .front-page-error {
        font-size: 12px;
        color: var(--text-muted);
        padding: 15px 0;
      }

      .front-page-error {
        color: var(--error-color);
      }

      .input-section label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }

      .input-section .microcopy {
        font-size: 11px;
        color: var(--text-muted);
        margin-top: 8px;
        line-height: 1.4;
      }

      .input-section .microcopy code {
        background: var(--hn-beige-dark);
        padding: 1px 4px;
        border-radius: 2px;
        font-size: 10px;
      }

      .manual-json-input {
        width: 100%;
        min-height: 150px;
        padding: 10px;
        font-family: monospace;
        font-size: 12px;
        border: 1px solid var(--border-color);
        border-radius: 3px;
        resize: vertical;
        box-sizing: border-box;
      }

      .manual-json-input:focus {
        outline: none;
        border-color: var(--hn-orange);
      }

      .input-row {
        display: flex;
        gap: 10px;
      }

      .input-row input[type="text"] {
        flex: 1;
        padding: 8px 10px;
        font-size: 13px;
        font-family: inherit;
        border: 1px solid var(--border-color);
        border-radius: 3px;
      }

      .input-row input[type="text"]:focus {
        outline: none;
        border-color: var(--hn-orange);
      }

      button {
        background-color: var(--hn-orange);
        color: white;
        border: none;
        padding: 8px 14px;
        font-size: 13px;
        font-family: inherit;
        border-radius: 3px;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      button:hover:not(:disabled) {
        background-color: var(--hn-orange-dark);
      }

      button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }

      /* Search Section */
      .search-section {
        background: white;
        padding: 15px;
        border-radius: 4px;
        margin-bottom: 20px;
        border: 1px solid var(--border-color);
        display: none;
        position: sticky;
        top: 0;
        z-index: 100;
        box-shadow: none;
        transition: box-shadow 0.2s;
      }

      .search-section.visible {
        display: block;
      }

      .search-section.stuck {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        border-radius: 0 0 4px 4px;
        margin-left: -20px;
        margin-right: -20px;
        padding-left: 35px;
        padding-right: 35px;
        width: calc(100% + 40px);
      }

      .search-row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .search-row input[type="text"] {
        width: 250px;
        padding: 6px 10px;
        font-size: 13px;
        font-family: inherit;
        border: 1px solid var(--border-color);
        border-radius: 3px;
      }

      .search-row input[type="text"]:focus {
        outline: none;
        border-color: var(--hn-orange);
      }

      .search-options {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .search-options label {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 11px;
        color: var(--text-secondary);
        cursor: pointer;
      }

      .search-options input[type="checkbox"] {
        cursor: pointer;
      }

      .search-nav {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-left: auto;
      }

      .search-nav button {
        padding: 4px 10px;
        font-size: 11px;
      }

      .search-counter {
        font-size: 11px;
        color: var(--text-muted);
        min-width: 80px;
        text-align: center;
      }

      /* View Options */
      .view-options {
        display: flex;
        gap: 15px;
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid var(--hn-beige-dark);
      }

      .view-options label {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 11px;
        color: var(--text-secondary);
        cursor: pointer;
      }

      /* Status Messages */
      .status {
        padding: 10px;
        margin-bottom: 15px;
        border-radius: 3px;
        display: none;
      }

      .status.loading {
        display: block;
        background: #e3f2fd;
        color: #1565c0;
      }

      .status.error {
        display: block;
        background: #ffebee;
        color: #c62828;
      }

      /* Thread Header */
      .thread-header {
        background: white;
        padding: 15px;
        border-radius: 4px;
        margin-bottom: 20px;
        border: 1px solid var(--border-color);
        display: none;
      }

      .thread-header.visible {
        display: block;
      }

      .thread-title {
        font-size: 16px;
        font-weight: bold;
        margin: 0 0 8px 0;
      }

      .thread-title a {
        color: var(--text-primary);
        text-decoration: none;
      }

      .thread-title a:hover {
        text-decoration: underline;
      }

      .thread-meta {
        font-size: 11px;
        color: var(--text-muted);
      }

      .thread-meta a {
        color: var(--text-muted);
        text-decoration: none;
      }

      .thread-meta a:hover {
        text-decoration: underline;
      }

      .thread-stats {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid var(--hn-beige-dark);
        font-size: 12px;
        color: var(--text-secondary);
      }

      /* Tree Container - Horizontal Row Layout */
      .tree-container {
        display: none;
      }

      .tree-container.visible {
        display: block;
      }

      /* Comment Row - horizontal container for siblings */
      .comment-row {
        display: flex;
        gap: 12px;
        padding: 10px 0;
        flex-wrap: nowrap;
        overflow: hidden;
        border-bottom: 1px solid var(--hn-beige-dark);
        position: relative;
        transition: background-color 0.15s ease;
        scroll-margin-top: 160px; /* Account for sticky header (~150px) */
      }

      .comment-row:last-child {
        border-bottom: none;
      }

      /* Last comment row (before .no-children-row) */
      .comment-row:has(+ .no-children-row) {
        border-bottom: none;
        background-color: transparent;
        /* opacity: 0.8; */
        background-size: 10px 10px;
        background-image: repeating-linear-gradient(
          45deg,
          var(--text-muted) 0,
          var(--text-muted) 1px,
          transparent 0,
          transparent 50%
        );
      }

      /* Keyboard-focused row */
      .comment-row.row-focused {
        background-color: hsl(45, 47%, 87%); /* ~10% darker than beige */
        outline: 3px solid var(--text-muted);
      }

      .comment-row:has(+ .no-children-row).row-focused {
        background-image: repeating-linear-gradient(
          45deg,
          var(--hn-orange-dark) 0,
          var(--hn-beige-dark) 1px,
          transparent 0,
          transparent 50%
        );
      }

      /* Depth indicator */
      .comment-row::before {
        content: attr(data-depth-label);
        position: absolute;
        left: 0;
        top: 5px;
        font-size: 12px;
        color: var(--text-muted);
        background: var(--hn-beige);
        padding: 2px 4px;
        border-radius: 2px;
      }

      .comment-row {
        padding-left: 50px;
      }

      /* Comment Box */
      .comment-box {
        background: white;
        border: 2px solid var(--border-color);
        border-radius: 4px;
        padding: 10px;
        width: 320px;
        min-width: 320px;
        position: relative;
        cursor: pointer;
        transition: all 0.15s ease;
      }

      /* Active (selected) comment */
      .comment-box.active {
        border-color: var(--hn-orange);
        box-shadow: 0 0 0 2px rgba(255, 102, 0, 0.2);
        opacity: 1;
      }

      /* Inactive (sibling) comment */
      .comment-box.inactive {
        border-color: var(--border-color);
      }

      .comment-box.inactive:hover {
        border-color: var(--hn-orange-dark);
      }

      .comment-box.inactive > div {
        opacity: var(--inactive-opacity);
      }

      .comment-box.inactive:hover > div {
        opacity: 0.85;
      }

      .comment-box.deleted {
        background: var(--deleted-bg);
        font-style: italic;
        color: var(--text-muted);
      }

      /* Search focused state */
      .comment-box.search-focused {
        box-shadow: 0 0 0 3px var(--highlight-bg);
      }

      .comment-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 6px;
        gap: 8px;
      }

      .comment-author {
        font-weight: bold;
        color: var(--text-secondary);
        text-decoration: none;
        font-size: 11px;
      }

      .comment-author:hover {
        text-decoration: underline;
      }

      .comment-link {
        font-size: 10px;
        color: var(--text-muted);
        text-decoration: none;
      }

      .comment-link:hover {
        text-decoration: underline;
      }

      .comment-text {
        font-size: 12px;
        line-height: 1.5;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }

      .comment-text pre,
      .comment-text table {
        overflow: auto;
      }

      .comment-text.truncated {
        display: -webkit-box;
        -webkit-line-clamp: 16;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .comment-text mark {
        background-color: var(--highlight-bg);
        padding: 0 2px;
      }

      .expand-text-btn {
        display: inline-block;
        margin-top: 5px;
        font-size: 11px;
        color: var(--hn-orange);
        cursor: pointer;
        border: none;
        background: none;
        padding: 0;
      }

      .expand-text-btn:hover {
        text-decoration: underline;
      }

      /* Comment Footer with stats */
      .comment-footer {
        display: flex;
        gap: 8px;
        margin-top: 8px;
        padding-top: 6px;
        border-top: 1px solid var(--hn-beige-dark);
        font-size: 10px;
        color: var(--text-muted);
        align-items: center;
        flex-wrap: wrap;
      }

      .comment-stat {
        display: flex;
        gap: 3px;
      }

      .comment-stat.has-children {
        color: var(--hn-orange);
        font-weight: bold;
      }

      /* Sibling navigation in footer */
      .sibling-nav {
        display: flex;
        gap: 4px;
        margin-left: auto;
        align-items: center;
      }

      .sibling-nav button {
        padding: 2px 6px;
        font-size: 9px;
        background: var(--hn-beige);
        color: var(--text-secondary);
        border: 1px solid var(--border-color);
      }

      .sibling-nav button:hover:not(:disabled) {
        background: var(--hn-beige-dark);
      }

      .sibling-nav button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      /* Ghost indicator for hidden left siblings */
      .siblings-left-indicator {
        display: flex;
        align-items: center;
        justify-content: end;
        min-width: 60px;
        padding: 10px;
        background: white;
        border: 2px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-muted);
        font-size: 11px;
        cursor: pointer;
        /* opacity: 0.7; */
        margin-left: -72px;
        transition: opacity 0.15s;
      }

      .siblings-left-indicator:hover {
        opacity: 1;
        border-color: var(--hn-orange);
      }

      /* No children indicator */
      .no-children-row {
        padding: 15px 50px;
        color: var(--text-muted);
        font-style: italic;
        font-size: 12px;
        height: 30vh;
      }

      /* Floating copy button */
      .floating-copy-btn {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 10px 16px;
        background-color: var(--hn-orange);
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 12px;
        font-family: inherit;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: background-color 0.15s, transform 0.1s;
        z-index: 1000;
      }

      .floating-copy-btn:hover {
        background-color: var(--hn-orange-dark);
      }

      .floating-copy-btn:active {
        transform: scale(0.98);
      }

      .floating-copy-btn.copied {
        background-color: #28a745;
      }
    </style>
  </head>
  <body>
    <h1>üå≥ Hacker News Comment Tree Visualizer</h1>
    <div
      id="debug-banner"
      style="
        display: none;
        background: #fff3cd;
        border: 1px solid #ffc107;
        padding: 8px 12px;
        border-radius: 4px;
        margin-bottom: 15px;
        font-size: 12px;
        color: #856404;
      "
    >
      üîß <strong>Debug Mode:</strong>
      <span id="debug-banner-text"
        >Using mock data. Any ID/URL will return the same test thread.</span
      >
      <a href="?" style="color: #856404">Disable</a>
    </div>

    <div class="input-section">
      <div class="input-tabs">
        <button class="input-tab active" data-tab="hn-link">HN Link/ID</button>
        <button class="input-tab" data-tab="custom-json">Custom JSON</button>
      </div>

      <div id="tab-hn-link" class="input-tab-content active">
        <label for="hn-input">Enter a Hacker News post ID or URL:</label>
        <div class="input-row">
          <input
            type="text"
            id="hn-input"
            placeholder="e.g., 39581733 or https://news.ycombinator.com/item?id=39581733"
          />
          <button id="fetch-btn">Fetch Thread</button>
        </div>
        <div class="front-page-header">
          <label>Or pick from the front page:</label>
          <a id="front-page-refresh" class="front-page-refresh">refresh</a>
        </div>
        <div id="front-page-container">
          <div class="front-page-loading">Loading front page stories...</div>
        </div>
      </div>

      <div id="tab-custom-json" class="input-tab-content">
        <label for="manual-json">Paste custom JSON payload:</label>
        <textarea
          id="manual-json"
          class="manual-json-input"
          placeholder='{"id": 123, "title": "Post title", "author": "username", "children": [...]}'
        ></textarea>
        <div class="input-row" style="margin-top: 10px">
          <button id="load-json-btn">Load JSON</button>
        </div>
        <p class="microcopy">
          Expected format: <code>{ id, title, author, children: [...] }</code
          ><br />
          Each comment:
          <code>{ id, author, text, created_at?, children: [...] }</code
          ><br /><br />
          üí° Tip: Have an LLM generate the payload with a prompt like:<br />
          <code
            >Generate a sample JSON payload for a nested HN discussion that
            might be returned via the Algolia API. The payload should contain no
            more than 40 comments and will be for an article titled "Show HN: I
            built a tool to visualize Hacker News comment threads"</code
          >
        </p>
      </div>
    </div>

    <div id="status" class="status"></div>

    <div id="search-section" class="search-section">
      <div class="search-row">
        <input type="text" id="search-input" placeholder="Search comments..." />
        <div class="search-options">
          <label>
            <input type="checkbox" id="search-authors" /> Search author names
          </label>
          <label>
            <input type="checkbox" id="search-case" /> Case sensitive
          </label>
        </div>
        <div class="search-nav">
          <button id="search-prev" disabled>‚óÄ Prev</button>
          <span id="search-counter" class="search-counter">0 of 0</span>
          <button id="search-next" disabled>Next ‚ñ∂</button>
        </div>
      </div>
      <div class="view-options">
        <label>
          <input type="checkbox" id="sort-by-activity" checked /> Sort by most
          discussed (participants)
        </label>
        <span
          style="font-size: 10px; color: var(--text-muted); margin-left: auto"
        >
          ‚Üë‚Üì rows ‚Ä¢ ‚Üê‚Üí selection ‚Ä¢ Enter expand
        </span>
      </div>
    </div>

    <div id="thread-header" class="thread-header">
      <h2 class="thread-title">
        <a id="thread-title-link" href="#" target="_blank"></a>
      </h2>
      <div class="thread-meta">
        by <a id="thread-author" href="#" target="_blank"></a> ‚Ä¢
        <a id="thread-hn-link" href="#" target="_blank">view on HN</a>
      </div>
      <div class="thread-stats" id="thread-stats"></div>
    </div>

    <div id="tree-container" class="tree-container"></div>

    <button id="copy-thread-btn" class="floating-copy-btn">
      üìã Copy row for LLM (0 context + 0 siblings)
    </button>

    <script>
      // ============================================
      // Debug Mode Detection
      // ============================================
      const urlParams = new URLSearchParams(window.location.search);
      const isDebugMock = urlParams.get("debug") === "mock";

      // Tab switching functionality
      function switchTab(tabName) {
        document.querySelectorAll(".input-tab").forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.tab === tabName);
        });
        document.querySelectorAll(".input-tab-content").forEach((content) => {
          content.classList.toggle("active", content.id === `tab-${tabName}`);
        });
      }

      document.querySelectorAll(".input-tab").forEach((tab) => {
        tab.addEventListener("click", () => switchTab(tab.dataset.tab));
      });

      // Debug mock mode initialization is handled after MOCK_HN_RESPONSE is defined
      // (see the mock data script at the end of the file)

      // ============================================
      // Front Page Stories
      // ============================================
      const FRONT_PAGE_CACHE_KEY = "hn_front_page_cache";
      const FRONT_PAGE_CACHE_TTL = 60 * 60 * 1000; // 60 minutes in ms

      async function fetchFrontPageStories(bustCache = false) {
        const container = document.getElementById("front-page-container");

        // Check cache first
        if (!bustCache) {
          const cached = localStorage.getItem(FRONT_PAGE_CACHE_KEY);
          if (cached) {
            try {
              const { data, timestamp } = JSON.parse(cached);
              if (Date.now() - timestamp < FRONT_PAGE_CACHE_TTL) {
                renderFrontPageStories(data);
                return;
              }
            } catch (e) {
              // Invalid cache, continue to fetch
            }
          }
        }

        // Show loading state
        container.innerHTML =
          '<div class="front-page-loading">Loading front page stories...</div>';

        try {
          const response = await fetch(
            "https://hn.algolia.com/api/v1/search?tags=front_page&hitsPerPage=30"
          );

          if (!response.ok) {
            throw new Error("Failed to fetch front page");
          }

          const data = await response.json();

          // Cache the response
          localStorage.setItem(
            FRONT_PAGE_CACHE_KEY,
            JSON.stringify({ data: data.hits, timestamp: Date.now() })
          );

          renderFrontPageStories(data.hits);
        } catch (error) {
          container.innerHTML = `<div class="front-page-error">Failed to load front page: ${error.message}</div>`;
        }
      }

      function renderFrontPageStories(stories) {
        const container = document.getElementById("front-page-container");

        if (!stories || stories.length === 0) {
          container.innerHTML =
            '<div class="front-page-error">No stories found</div>';
          return;
        }

        const list = document.createElement("ul");
        list.className = "front-page-list";

        stories.forEach((story) => {
          const item = document.createElement("li");
          item.className = "front-page-item";

          const title = document.createElement("a");
          title.className = "front-page-title";
          title.textContent = story.title || "[No title]";
          title.addEventListener("click", () => {
            document.getElementById("hn-input").value = story.objectID;
            fetchThread();
          });

          const meta = document.createElement("div");
          meta.className = "front-page-meta";
          meta.textContent = `by ${story.author || "unknown"} ¬∑ ${
            story.num_comments ?? 0
          } comments`;

          item.appendChild(title);
          item.appendChild(meta);
          list.appendChild(item);
        });

        container.innerHTML = "";
        container.appendChild(list);
      }

      // Refresh button handler
      document
        .getElementById("front-page-refresh")
        .addEventListener("click", (e) => {
          e.preventDefault();
          fetchFrontPageStories(true);
        });

      // Load front page stories on init (skip if auto-loading a specific ID)
      if (!urlParams.get("id")) {
        fetchFrontPageStories();
      }

      // ============================================
      // Global State
      // ============================================
      let threadData = null;
      let allComments = [];
      let selectedPath = []; // Array of selected comment IDs at each depth
      let sortByActivity = true; // Default ON
      let focusedRowIndex = 0; // Currently keyboard-focused row
      let searchMatches = [];
      let currentMatchIndex = -1;

      // ============================================
      // DOM Elements
      // ============================================
      const hnInput = document.getElementById("hn-input");
      const fetchBtn = document.getElementById("fetch-btn");
      const manualJsonInput = document.getElementById("manual-json");
      const loadJsonBtn = document.getElementById("load-json-btn");
      const statusEl = document.getElementById("status");
      const searchSection = document.getElementById("search-section");
      const searchInput = document.getElementById("search-input");
      const searchAuthors = document.getElementById("search-authors");
      const searchCase = document.getElementById("search-case");
      const searchPrev = document.getElementById("search-prev");
      const searchNext = document.getElementById("search-next");
      const searchCounter = document.getElementById("search-counter");
      const sortByActivityCheckbox =
        document.getElementById("sort-by-activity");
      const threadHeader = document.getElementById("thread-header");
      const threadTitleLink = document.getElementById("thread-title-link");
      const threadAuthor = document.getElementById("thread-author");
      const threadHnLink = document.getElementById("thread-hn-link");
      const threadStats = document.getElementById("thread-stats");
      const copyThreadBtn = document.getElementById("copy-thread-btn");
      const treeContainer = document.getElementById("tree-container");

      // ============================================
      // Utility Functions
      // ============================================
      function extractHnId(input) {
        const trimmed = input.trim();
        if (/^\d+$/.test(trimmed)) {
          return trimmed;
        }
        const match = trimmed.match(/id=(\d+)/);
        if (match && match[1]) {
          return match[1];
        }
        throw new Error(
          "Invalid input. Please enter a valid Hacker News ID or URL."
        );
      }

      function cleanHtmlContent(text) {
        if (!text) return "";
        const tempElement = document.createElement("div");
        tempElement.innerHTML = text;
        // Make all links open in new tab
        tempElement.querySelectorAll("a").forEach((link) => {
          link.setAttribute("target", "_blank");
          link.setAttribute("rel", "noopener noreferrer");
        });
        return tempElement.innerHTML;
      }

      function stripHtml(html) {
        const tmp = document.createElement("div");
        tmp.innerHTML = html;
        return tmp.textContent || tmp.innerText || "";
      }

      function showStatus(message, type = "loading") {
        statusEl.textContent = message;
        statusEl.className = `status ${type}`;
      }

      function hideStatus() {
        statusEl.className = "status";
      }

      function escapeRegex(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      // ============================================
      // Copy Thread Functionality
      // ============================================
      function getThreadDataForCopy() {
        if (!threadData || selectedPath.length === 0) return null;

        const result = {
          ancestors: [],
          siblings: [],
        };

        // Add root as first ancestor
        result.ancestors.push({
          id: threadData.id,
          author: threadData.author || "unknown",
          text: threadData.title || "",
          parentAuthor: null,
        });

        // Add selected comments from each row leading up to (but not including) current row
        for (let i = 0; i < focusedRowIndex && i < selectedPath.length; i++) {
          const commentId = selectedPath[i];
          const comment = allComments.find((c) => c.id === commentId);
          if (comment) {
            const parentAuthor =
              i === 0
                ? threadData.author || "unknown"
                : allComments.find((c) => c.id === selectedPath[i - 1])
                    ?.author || "unknown";
            result.ancestors.push({ ...comment, parentAuthor });
          }
        }

        // Get siblings in the focused row
        const rows = document.querySelectorAll(".comment-row");
        if (rows[focusedRowIndex]) {
          const boxes = rows[focusedRowIndex].querySelectorAll(".comment-box");
          const parentAuthor =
            focusedRowIndex > 0 && selectedPath[focusedRowIndex - 1]
              ? allComments.find(
                  (c) => c.id === selectedPath[focusedRowIndex - 1]
                )?.author || "unknown"
              : threadData.author || "unknown";

          boxes.forEach((box) => {
            const commentId = parseInt(box.dataset.commentId);
            const comment = allComments.find((c) => c.id === commentId);
            if (comment) {
              result.siblings.push({ ...comment, parentAuthor });
            }
          });
        }

        return result;
      }

      function formatThreadForClipboard(data) {
        if (!data) return "";

        const lines = [];

        // Format ancestors
        data.ancestors.forEach((comment, index) => {
          const author = comment.author || "unknown";
          const text = stripHtml(comment.text || "").trim();

          if (index === 0) {
            // Root/original post
            lines.push(`[original post by ${author}]:`);
            lines.push(text || "(no text)");
          } else {
            lines.push(`[reply to ${comment.parentAuthor} by ${author}]:`);
            lines.push(text);
          }
          lines.push("");
        });

        // Format siblings
        data.siblings.forEach((comment, index) => {
          const author = comment.author || "unknown";
          const text = stripHtml(comment.text || "").trim();
          const replyNum = data.siblings.length > 1 ? `#${index + 1} ` : "";

          lines.push(
            `[reply ${replyNum}to ${comment.parentAuthor} by ${author}]:`
          );
          lines.push(text);
          lines.push("");
        });

        return lines.join("\n").trim();
      }

      function updateCopyButtonText() {
        if (!threadData) {
          copyThreadBtn.style.display = "none";
          return;
        }

        const data = getThreadDataForCopy();
        if (!data) {
          copyThreadBtn.style.display = "none";
          return;
        }

        const contextCount = data.ancestors.length;
        const siblingsCount = data.siblings.length;
        copyThreadBtn.textContent = `üìã Copy row for LLM (${contextCount} context + ${siblingsCount} siblings)`;
        copyThreadBtn.style.display = "block";
      }

      async function copyThreadToClipboard() {
        const data = getThreadDataForCopy();
        const text = formatThreadForClipboard(data);

        if (!text) {
          return;
        }

        try {
          await navigator.clipboard.writeText(text);
          copyThreadBtn.classList.add("copied");
          copyThreadBtn.textContent = "‚úì Copied!";
          setTimeout(() => {
            copyThreadBtn.classList.remove("copied");
            updateCopyButtonText();
          }, 1500);
        } catch (err) {
          console.error("Failed to copy:", err);
        }
      }

      copyThreadBtn.addEventListener("click", copyThreadToClipboard);

      // ============================================
      // Data Processing
      // ============================================
      function flattenComments(node, depth = 0, parentId = null, list = []) {
        if (!node) return list;

        const comment = {
          id: node.id,
          author: node.author,
          text: node.text || "",
          deleted: !node.author || node.deleted,
          depth: depth,
          parentId: parentId,
          childIds: [],
        };

        list.push(comment);

        if (node.children && node.children.length > 0) {
          for (const child of node.children) {
            comment.childIds.push(child.id);
            flattenComments(child, depth + 1, node.id, list);
          }
        }

        return list;
      }

      function calculateSubtreeStats(commentId) {
        const comment = allComments.find((c) => c.id === commentId);
        if (!comment) return { count: 0, users: 0 };

        let count = 0;
        let users = new Set();

        function traverse(id) {
          const c = allComments.find((x) => x.id === id);
          if (!c) return;

          count++;
          if (!c.deleted && c.author) {
            users.add(c.author);
          }

          for (const childId of c.childIds) {
            traverse(childId);
          }
        }

        traverse(commentId);

        return { count, users: users.size - 1 };
      }

      function getOrderedChildren(parentId) {
        const parent = allComments.find((c) => c.id === parentId);
        if (!parent || parent.childIds.length === 0) return [];

        let childIds = [...parent.childIds];

        if (sortByActivity) {
          // Sort by unique participants in subtree (descending)
          childIds.sort((a, b) => {
            const statsA = calculateSubtreeStats(a);
            const statsB = calculateSubtreeStats(b);
            return statsB.users - statsA.users;
          });
        }

        return childIds;
      }

      function getParentLineage(commentId) {
        const lineage = [];
        let current = allComments.find((c) => c.id === commentId);

        while (current && current.parentId) {
          lineage.unshift(current.parentId);
          current = allComments.find((c) => c.id === current.parentId);
        }

        return lineage;
      }

      // ============================================
      // Selection & Navigation
      // ============================================
      function initializeSelectedPath() {
        selectedPath = [];

        // Start with root's children
        const rootChildren = getOrderedChildren(threadData.id);
        if (rootChildren.length === 0) return;

        // Select first child at each level until we hit a leaf
        let currentId = rootChildren[0];
        selectedPath.push(currentId);

        while (true) {
          const children = getOrderedChildren(currentId);
          if (children.length === 0) break;
          currentId = children[0];
          selectedPath.push(currentId);
        }
      }

      function selectComment(commentId, depth) {
        // Update selected path at this depth
        selectedPath[depth] = commentId;

        // Clear selections below this depth
        selectedPath = selectedPath.slice(0, depth + 1);

        // Auto-select first child at each subsequent level
        let currentId = commentId;
        while (true) {
          const children = getOrderedChildren(currentId);
          if (children.length === 0) break;
          currentId = children[0];
          selectedPath.push(currentId);
        }

        // Update focused row to match the clicked depth
        focusedRowIndex = depth;

        renderTree();
        updateRowFocus();

        // Re-apply search highlights
        if (searchInput.value.trim()) {
          document.querySelectorAll(".comment-text").forEach((el) => {
            highlightSearchInComment(el);
          });
        }
      }

      // Update visual focus on rows
      function updateRowFocus() {
        const rows = document.querySelectorAll(".comment-row");
        rows.forEach((row, index) => {
          row.classList.toggle("row-focused", index === focusedRowIndex);
        });
        updateCopyButtonText();
      }

      // Scroll a comment box into view, accounting for sticky header
      function scrollCommentIntoView(commentId) {
        const commentBox = document.getElementById(`comment-${commentId}`);
        if (!commentBox) return;

        const stickyHeaderHeight = 160;
        const rect = commentBox.getBoundingClientRect();
        const viewportHeight = window.innerHeight;

        if (rect.top < stickyHeaderHeight) {
          // Comment is above visible area (behind sticky header) - scroll up
          const targetY = window.scrollY + rect.top - stickyHeaderHeight;
          window.scrollTo({ top: targetY, behavior: "smooth" });
        } else if (rect.bottom > viewportHeight) {
          // Comment is below visible area - scroll down
          const targetY = window.scrollY + rect.bottom - viewportHeight + 20;
          window.scrollTo({ top: targetY, behavior: "smooth" });
        }
      }

      // Keyboard navigation: move focus between rows
      function navigateRow(direction) {
        const rows = document.querySelectorAll(".comment-row");
        if (rows.length === 0) return;

        if (direction === "up") {
          focusedRowIndex = Math.max(0, focusedRowIndex - 1);
        } else {
          focusedRowIndex = Math.min(rows.length - 1, focusedRowIndex + 1);
        }

        updateRowFocus();

        // Scroll the focused row into view, accounting for sticky header
        const focusedRow = rows[focusedRowIndex];
        if (focusedRow) {
          const stickyHeaderHeight = 160;
          const rect = focusedRow.getBoundingClientRect();
          const viewportHeight = window.innerHeight;

          if (rect.top < stickyHeaderHeight) {
            // Row is above visible area (behind sticky header) - scroll up
            const targetY = window.scrollY + rect.top - stickyHeaderHeight;
            window.scrollTo({ top: targetY, behavior: "smooth" });
          } else if (rect.bottom > viewportHeight) {
            // Row is below visible area - scroll down
            const targetY = window.scrollY + rect.bottom - viewportHeight + 20;
            window.scrollTo({ top: targetY, behavior: "smooth" });
          }
        }
      }

      // Keyboard navigation: change selection within focused row
      function navigateSelection(direction) {
        if (focusedRowIndex >= selectedPath.length) return;

        const currentCommentId = selectedPath[focusedRowIndex];
        if (!currentCommentId) return;

        const comment = allComments.find((c) => c.id === currentCommentId);
        if (!comment) return;

        const parentId = comment.parentId || threadData.id;
        const siblings = getOrderedChildren(parentId);
        const currentIndex = siblings.indexOf(currentCommentId);

        let newIndex;
        if (direction === "left") {
          newIndex = Math.max(0, currentIndex - 1);
        } else {
          newIndex = Math.min(siblings.length - 1, currentIndex + 1);
        }

        if (newIndex !== currentIndex) {
          selectComment(siblings[newIndex], focusedRowIndex);
          scrollCommentIntoView(siblings[newIndex]);
        }
      }

      // Toggle expand/collapse of selected comment's text
      function toggleSelectedCommentText() {
        if (focusedRowIndex >= selectedPath.length) return;

        const currentCommentId = selectedPath[focusedRowIndex];
        if (!currentCommentId) return;

        const commentBox = document.getElementById(
          `comment-${currentCommentId}`
        );
        if (!commentBox) return;

        const expandBtn = commentBox.querySelector(".expand-text-btn");
        if (expandBtn) {
          expandBtn.click();
        }
      }

      function navigateToSibling(commentId, direction) {
        const comment = allComments.find((c) => c.id === commentId);
        if (!comment) return;

        const parentId = comment.parentId || threadData.id;
        const siblings = getOrderedChildren(parentId);
        const currentIndex = siblings.indexOf(commentId);

        let newIndex;
        if (direction === "prev") {
          newIndex = Math.max(0, currentIndex - 1);
        } else {
          newIndex = Math.min(siblings.length - 1, currentIndex + 1);
        }

        if (newIndex !== currentIndex) {
          const depth = selectedPath.indexOf(commentId);
          if (depth !== -1) {
            selectComment(siblings[newIndex], depth);
            scrollCommentIntoView(siblings[newIndex]);
          }
        }
      }

      // ============================================
      // Rendering
      // ============================================
      function renderThread() {
        if (!threadData) return;

        // Update header
        const hnUrl = `https://news.ycombinator.com/item?id=${threadData.id}`;
        threadTitleLink.textContent = threadData.title || "(No title)";
        threadTitleLink.href = threadData.url || hnUrl;
        threadAuthor.textContent = threadData.author || "unknown";
        threadAuthor.href = `https://news.ycombinator.com/user?id=${threadData.author}`;
        threadHnLink.href = hnUrl;

        // Calculate stats
        const totalComments = allComments.filter((c) => !c.deleted).length;
        const uniqueUsers = new Set(
          allComments.filter((c) => !c.deleted && c.author).map((c) => c.author)
        ).size;
        threadStats.textContent = `${totalComments} comments by ${uniqueUsers} unique participants`;

        threadHeader.classList.add("visible");
        searchSection.classList.add("visible");
        treeContainer.classList.add("visible");

        renderTree();
      }

      function renderTree() {
        treeContainer.innerHTML = "";

        const rootChildren = getOrderedChildren(threadData.id);
        if (rootChildren.length === 0) {
          treeContainer.innerHTML =
            '<p style="color: var(--text-muted); font-style: italic; padding: 15px;">No comments yet.</p>';
          return;
        }

        // Render each depth level as a row
        let currentParentId = threadData.id;
        let depth = 0;

        while (true) {
          const siblings = getOrderedChildren(currentParentId);
          if (siblings.length === 0) {
            // Show "no more replies" indicator if we went at least one level deep
            if (depth > 0) {
              const noChildrenEl = document.createElement("div");
              noChildrenEl.className = "no-children-row";
              noChildrenEl.textContent = "‚ìß No more replies in this branch";
              treeContainer.appendChild(noChildrenEl);
            }
            break;
          }

          const selectedAtThisDepth = selectedPath[depth];
          const rowEl = renderCommentRow(siblings, selectedAtThisDepth, depth);
          treeContainer.appendChild(rowEl);

          // Move to next level (children of selected comment)
          if (!selectedAtThisDepth) break;
          currentParentId = selectedAtThisDepth;
          depth++;
        }
      }

      function renderCommentRow(siblingIds, selectedId, depth) {
        const rowEl = document.createElement("div");
        rowEl.className = "comment-row";
        rowEl.dataset.depth = depth;
        rowEl.dataset.depthLabel = `Lvl ${depth + 1}`;

        // Start rendering from selected comment onwards (selected always first)
        const selectedIndex = siblingIds.indexOf(selectedId);
        const startIndex = selectedIndex >= 0 ? selectedIndex : 0;
        const hiddenLeftCount = startIndex;

        // Add ghost indicator if there are siblings to the left
        if (hiddenLeftCount > 0) {
          const ghostEl = document.createElement("div");
          ghostEl.className = "siblings-left-indicator";
          ghostEl.textContent = `‚Üê${hiddenLeftCount}`;
          ghostEl.title = `${hiddenLeftCount} more comment${
            hiddenLeftCount > 1 ? "s" : ""
          } to the left (press ‚Üê)`;
          ghostEl.onclick = () => navigateSelection("left");
          rowEl.appendChild(ghostEl);
        }

        const visibleSiblings = siblingIds.slice(startIndex);

        for (const commentId of visibleSiblings) {
          const isSelected = commentId === selectedId;
          const boxEl = renderCommentBox(commentId, isSelected, depth);
          rowEl.appendChild(boxEl);
        }

        return rowEl;
      }

      function renderCommentBox(commentId, isSelected, depth) {
        const comment = allComments.find((c) => c.id === commentId);
        if (!comment) return document.createElement("div");

        const boxEl = document.createElement("div");
        boxEl.className = "comment-box";
        boxEl.id = `comment-${commentId}`;
        boxEl.dataset.commentId = commentId;

        if (isSelected) {
          boxEl.classList.add("active");
        } else {
          boxEl.classList.add("inactive");
        }

        if (comment.deleted) {
          boxEl.classList.add("deleted");
        }

        // Click to select (unless clicking a link or selecting text)
        boxEl.addEventListener("click", (e) => {
          if (e.target.tagName === "A" || e.target.tagName === "BUTTON") return;
          // Don't trigger selection if user is selecting text
          const selection = window.getSelection();
          if (selection && selection.toString().length > 0) return;
          selectComment(commentId, depth);
          scrollCommentIntoView(commentId);
        });

        // Header
        const headerEl = document.createElement("div");
        headerEl.className = "comment-header";

        if (comment.deleted) {
          const deletedSpan = document.createElement("span");
          deletedSpan.className = "comment-author";
          deletedSpan.textContent = "[deleted]";
          headerEl.appendChild(deletedSpan);
        } else {
          const authorLink = document.createElement("a");
          authorLink.className = "comment-author";
          authorLink.href = `https://news.ycombinator.com/user?id=${comment.author}`;
          authorLink.target = "_blank";
          authorLink.textContent = comment.author;
          headerEl.appendChild(authorLink);
        }

        const hnLink = document.createElement("a");
        hnLink.className = "comment-link";
        hnLink.href = `https://news.ycombinator.com/item?id=${commentId}`;
        hnLink.target = "_blank";
        hnLink.textContent = "link";
        headerEl.appendChild(hnLink);

        boxEl.appendChild(headerEl);

        // Text content
        const textEl = document.createElement("div");
        textEl.className = "comment-text";

        if (comment.deleted) {
          textEl.textContent = "[comment deleted]";
        } else {
          textEl.innerHTML = cleanHtmlContent(comment.text);
          // Apply truncation initially to check if content actually overflows
          textEl.classList.add("truncated");
        }

        boxEl.appendChild(textEl);

        // After element is in DOM, check if truncation is actually needed
        if (!comment.deleted) {
          requestAnimationFrame(() => {
            // scrollHeight > clientHeight means content is being clipped
            const isOverflowing = textEl.scrollHeight > textEl.clientHeight + 1;

            if (isOverflowing) {
              // Keep truncated class and add expand button (before footer)
              const expandBtn = document.createElement("button");
              expandBtn.className = "expand-text-btn";
              expandBtn.textContent = "[expand]";
              expandBtn.onclick = (e) => {
                e.stopPropagation();
                toggleTextExpand(textEl, expandBtn);
              };
              const footer = boxEl.querySelector(".comment-footer");
              boxEl.insertBefore(expandBtn, footer);
            } else {
              // Content fits - remove unnecessary truncation
              textEl.classList.remove("truncated");
            }
          });
        }

        // Footer with stats and navigation
        const footerEl = document.createElement("div");
        footerEl.className = "comment-footer";

        // Subtree stats
        const stats = calculateSubtreeStats(commentId);
        const hasChildren = comment.childIds.length > 0;

        if (hasChildren) {
          const childStat = document.createElement("span");
          childStat.className = "comment-stat has-children";
          childStat.textContent = `‚Üì ${stats.count - 1} replies`;
          footerEl.appendChild(childStat);

          const userStat = document.createElement("span");
          userStat.className = "comment-stat";
          if (stats.users == 1) {
            userStat.textContent = `1 person`;
          } else {
            userStat.textContent = `${stats.users} people`;
          }
          footerEl.appendChild(userStat);
        } else {
          const leafStat = document.createElement("span");
          leafStat.className = "comment-stat";
          leafStat.textContent = "leaf";
          footerEl.appendChild(leafStat);
        }

        // Sibling navigation (only for active comment)
        if (isSelected) {
          const parentId = comment.parentId || threadData.id;
          const siblings = getOrderedChildren(parentId);
          const currentIndex = siblings.indexOf(commentId);

          const sibNavEl = document.createElement("div");
          sibNavEl.className = "sibling-nav";

          const prevBtn = document.createElement("button");
          prevBtn.textContent = "‚óÄ Prev";
          prevBtn.disabled = currentIndex === 0;
          prevBtn.onclick = (e) => {
            e.stopPropagation();
            navigateToSibling(commentId, "prev");
          };
          sibNavEl.appendChild(prevBtn);

          const posIndicator = document.createElement("span");
          posIndicator.style.fontSize = "9px";
          posIndicator.style.color = "var(--text-muted)";
          posIndicator.textContent = `${currentIndex + 1}/${siblings.length}`;
          sibNavEl.appendChild(posIndicator);

          const nextBtn = document.createElement("button");
          nextBtn.textContent = "Next ‚ñ∂";
          nextBtn.disabled = currentIndex === siblings.length - 1;
          nextBtn.onclick = (e) => {
            e.stopPropagation();
            navigateToSibling(commentId, "next");
          };
          sibNavEl.appendChild(nextBtn);

          footerEl.appendChild(sibNavEl);
        }

        boxEl.appendChild(footerEl);

        return boxEl;
      }

      function toggleTextExpand(textEl, btn) {
        const isExpanded = !textEl.classList.contains("truncated");

        if (isExpanded) {
          textEl.classList.add("truncated");
          btn.textContent = "[expand]";
        } else {
          textEl.classList.remove("truncated");
          btn.textContent = "[collapse]";
        }
      }

      // ============================================
      // Search Functionality
      // ============================================
      function performSearch() {
        const query = searchInput.value.trim();

        // Clear previous highlights
        document.querySelectorAll(".comment-text mark").forEach((mark) => {
          const parent = mark.parentNode;
          parent.replaceChild(document.createTextNode(mark.textContent), mark);
          parent.normalize();
        });

        // Clear search focus styling
        document
          .querySelectorAll(".comment-box.search-focused")
          .forEach((el) => {
            el.classList.remove("search-focused");
          });

        searchMatches = [];
        currentMatchIndex = -1;

        if (!query) {
          updateSearchCounter();
          return;
        }

        const includeAuthors = searchAuthors.checked;
        const caseSensitive = searchCase.checked;
        const flags = caseSensitive ? "g" : "gi";
        const regex = new RegExp(escapeRegex(query), flags);

        // Find all matching comments
        for (const comment of allComments) {
          if (comment.deleted) continue;
          if (comment.id === threadData.id) continue; // Skip root

          const textContent = stripHtml(comment.text);
          const authorMatch =
            includeAuthors && comment.author && regex.test(comment.author);
          const textMatch = regex.test(textContent);

          if (authorMatch || textMatch) {
            searchMatches.push(comment.id);
          }

          regex.lastIndex = 0;
        }

        // Highlight matches in visible comments
        document.querySelectorAll(".comment-text").forEach((el) => {
          highlightSearchInComment(el);
        });

        updateSearchCounter();

        // Navigate to first match
        if (searchMatches.length > 0) {
          currentMatchIndex = 0;
          navigateToSearchMatch(searchMatches[0]);
          updateSearchCounter();
        }
      }

      function navigateToSearchMatch(commentId) {
        // Build the path to this comment
        const lineage = getParentLineage(commentId);

        // Reset selected path to follow this lineage
        selectedPath = [];

        // Add each ancestor to the path
        for (const ancestorId of lineage) {
          if (ancestorId !== threadData.id) {
            selectedPath.push(ancestorId);
          }
        }

        // Add the target comment itself
        selectedPath.push(commentId);

        // Continue selection to first children below
        let currentId = commentId;
        while (true) {
          const children = getOrderedChildren(currentId);
          if (children.length === 0) break;
          currentId = children[0];
          selectedPath.push(currentId);
        }

        // Update focused row to the depth of the found comment
        focusedRowIndex = selectedPath.indexOf(commentId);
        if (focusedRowIndex === -1) focusedRowIndex = 0;

        renderTree();
        updateRowFocus();

        // Re-apply highlights and scroll to the match
        document.querySelectorAll(".comment-text").forEach((el) => {
          highlightSearchInComment(el);
        });

        const commentBox = document.getElementById(`comment-${commentId}`);
        if (commentBox) {
          commentBox.classList.add("search-focused");
          commentBox.scrollIntoView({ behavior: "smooth", block: "center" });
        }
      }

      function highlightSearchInComment(textEl) {
        const query = searchInput.value.trim();
        if (!query) return;

        const caseSensitive = searchCase.checked;
        const flags = caseSensitive ? "g" : "gi";
        const regex = new RegExp(`(${escapeRegex(query)})`, flags);

        const walker = document.createTreeWalker(
          textEl,
          NodeFilter.SHOW_TEXT,
          null,
          false
        );
        const textNodes = [];

        while (walker.nextNode()) {
          textNodes.push(walker.currentNode);
        }

        for (const node of textNodes) {
          if (regex.test(node.textContent)) {
            const span = document.createElement("span");
            span.innerHTML = node.textContent.replace(regex, "<mark>$1</mark>");
            node.parentNode.replaceChild(span, node);
          }
          regex.lastIndex = 0;
        }
      }

      function updateSearchCounter() {
        const total = searchMatches.length;
        const current = total > 0 ? currentMatchIndex + 1 : 0;
        searchCounter.textContent = `${current} of ${total}`;

        searchPrev.disabled = total === 0 || currentMatchIndex <= 0;
        searchNext.disabled = total === 0 || currentMatchIndex >= total - 1;
      }

      function navigateSearchPrev() {
        if (currentMatchIndex > 0) {
          currentMatchIndex--;
          navigateToSearchMatch(searchMatches[currentMatchIndex]);
          updateSearchCounter();
        }
      }

      function navigateSearchNext() {
        if (currentMatchIndex < searchMatches.length - 1) {
          currentMatchIndex++;
          navigateToSearchMatch(searchMatches[currentMatchIndex]);
          updateSearchCounter();
        }
      }

      // ============================================
      // Data Processing
      // ============================================
      function processThreadData(data) {
        threadData = data;

        // Flatten comments for easier processing
        allComments = [];
        if (threadData.children) {
          for (const child of threadData.children) {
            flattenComments(child, 0, threadData.id, allComments);
          }
        }

        // Add root entry
        allComments.unshift({
          id: threadData.id,
          author: threadData.author,
          text: threadData.title || "",
          deleted: false,
          depth: -1,
          parentId: null,
          childIds: threadData.children
            ? threadData.children.map((c) => c.id)
            : [],
        });

        // Initialize selection
        initializeSelectedPath();
        focusedRowIndex = 0;

        hideStatus();
        renderThread();
        updateRowFocus();

        // Scroll to first row after render
        setTimeout(() => {
          const firstRow = document.querySelector(".comment-row");
          if (firstRow) {
            firstRow.scrollIntoView({ behavior: "smooth", block: "start" });
          }
        }, 50);
      }

      // ============================================
      // Data Fetching
      // ============================================
      async function fetchThread() {
        const input = hnInput.value.trim();
        if (!input) {
          showStatus("Please enter a Hacker News ID or URL", "error");
          return;
        }

        hnInput.blur();

        try {
          const hnId = extractHnId(input);
          showStatus(`Fetching thread ${hnId}...`, "loading");

          const response = await fetch(
            `https://hn.algolia.com/api/v1/items/${hnId}`
          );

          if (!response.ok) {
            throw new Error(
              `Failed to fetch: ${response.status} ${response.statusText}`
            );
          }

          const data = await response.json();
          processThreadData(data);
        } catch (error) {
          showStatus(error.message, "error");
        }
      }

      // ============================================
      // Event Listeners
      // ============================================
      fetchBtn.addEventListener("click", fetchThread);

      hnInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          fetchThread();
        }
      });

      // Manual JSON mode handlers
      loadJsonBtn.addEventListener("click", loadManualJson);

      function loadManualJson() {
        const jsonText = manualJsonInput.value.trim();
        if (!jsonText) {
          showStatus("Please paste JSON data", "error");
          return;
        }

        try {
          const data = JSON.parse(jsonText);

          // Basic validation
          if (!data.id || !data.children) {
            showStatus(
              "Invalid format: JSON must have 'id' and 'children' properties",
              "error"
            );
            return;
          }

          manualJsonInput.blur();
          showStatus("Loading custom JSON...", "loading");

          // Small delay for visual feedback
          setTimeout(() => {
            processThreadData(data);
            showStatus("Custom thread loaded successfully!", "success");
          }, 100);
        } catch (e) {
          showStatus(`Invalid JSON: ${e.message}`, "error");
        }
      }

      let searchTimeout;
      searchInput.addEventListener("input", () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(performSearch, 300);
      });

      searchAuthors.addEventListener("change", performSearch);
      searchCase.addEventListener("change", performSearch);
      searchPrev.addEventListener("click", navigateSearchPrev);
      searchNext.addEventListener("click", navigateSearchNext);

      sortByActivityCheckbox.addEventListener("change", () => {
        sortByActivity = sortByActivityCheckbox.checked;
        if (threadData) {
          initializeSelectedPath();
          focusedRowIndex = 0;
          renderTree();
          updateRowFocus();
          // Re-apply search if active
          if (searchInput.value.trim()) {
            performSearch();
          }
        }
      });

      // Keyboard navigation
      document.addEventListener("keydown", (e) => {
        // Only handle if we have data and not typing in an input
        if (!threadData) return;
        if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")
          return;

        switch (e.key) {
          case "ArrowUp":
            e.preventDefault();
            if (e.shiftKey) {
              // Jump to first row
              focusedRowIndex = 0;
              updateRowFocus();
              scrollCommentIntoView(selectedPath[0]);
            } else {
              navigateRow("up");
            }
            break;
          case "ArrowDown":
            e.preventDefault();
            navigateRow("down");
            break;
          case "ArrowLeft":
            e.preventDefault();
            navigateSelection("left");
            break;
          case "ArrowRight":
            e.preventDefault();
            navigateSelection("right");
            break;
          case "Enter":
            e.preventDefault();
            toggleSelectedCommentText();
            break;
        }
      });

      // Sticky search bar detection
      const stickyObserver = new IntersectionObserver(
        ([entry]) => {
          // When the sentinel goes out of view, the search bar is "stuck"
          searchSection.classList.toggle("stuck", !entry.isIntersecting);
        },
        { threshold: 0, rootMargin: "-1px 0px 0px 0px" }
      );

      // Create a sentinel element right before the search section
      const stickySentinel = document.createElement("div");
      stickySentinel.style.height = "1px";
      stickySentinel.style.marginBottom = "-1px";
      searchSection.parentNode.insertBefore(stickySentinel, searchSection);
      stickyObserver.observe(stickySentinel);

      // Auto-load from URL param ?id=...
      const autoLoadId = urlParams.get("id");
      if (autoLoadId) {
        hnInput.value = autoLoadId;
        fetchThread();
      }
    </script>

    <!-- ================================================================
         MOCK DATA FOR DEBUG MODE - Remove this entire script tag in production
         Usage: Add ?debug=mock to the URL to use this mock data
         ================================================================ -->
    <script>
      const MOCK_HN_RESPONSE = {
        id: 12345678,
        title:
          "Show HN: I built a tool to visualize Hacker News comment threads",
        url: "https://example.com/hn-visualizer",
        author: "pg",
        created_at: "2024-01-15T10:30:00.000Z",
        type: "story",
        children: [
          {
            id: 12345679,
            author: "dang",
            text: "This is really cool! I've been wanting something like this for a long time. The nested comment structure on HN can get pretty hard to follow, especially in heated discussions with lots of back-and-forth.",
            created_at: "2024-01-15T10:35:00.000Z",
            children: [
              {
                id: 12345680,
                author: "pg",
                text: "Thanks! That was exactly the motivation. I found myself losing track of who was replying to whom in deep threads.",
                created_at: "2024-01-15T10:40:00.000Z",
                children: [
                  {
                    id: 12345681,
                    author: "dang",
                    text: "Have you considered adding keyboard shortcuts? j/k for next/prev comment would be great.",
                    created_at: "2024-01-15T10:45:00.000Z",
                    children: [
                      {
                        id: 12345682,
                        author: "pg",
                        text: "That's on the roadmap! Might add vim-style navigation too.",
                        created_at: "2024-01-15T10:50:00.000Z",
                        children: [],
                      },
                    ],
                  },
                ],
              },
              {
                id: 12345683,
                author: "tptacek",
                text: "The visualization approach reminds me of some academic work on forum thread analysis. Have you seen the ThreadVis paper from CHI 2006?",
                created_at: "2024-01-15T10:42:00.000Z",
                children: [],
              },
            ],
          },
          {
            id: 12345684,
            author: "patio11",
            text: "<p>This is a fantastic tool. I particularly like the collapse feature - it makes it much easier to skim through long discussions.</p><p>One suggestion: it would be helpful to see timestamps on comments to understand the flow of the conversation. Sometimes the order matters a lot for context.</p><p>Also, any plans to support other platforms like Reddit or Twitter threads? The same visualization concept could work really well there too.</p>",
            created_at: "2024-01-15T11:00:00.000Z",
            children: [
              {
                id: 12345685,
                author: "pg",
                text: "Great feedback! Timestamps are definitely something I'm considering. For other platforms, I'd need to look into their APIs - Reddit's is pretty accessible but Twitter's is... complicated these days.",
                created_at: "2024-01-15T11:15:00.000Z",
                children: [
                  {
                    id: 12345686,
                    author: "patio11",
                    text: "Yeah, the Twitter API situation is unfortunate. Reddit would probably be the most valuable next target given the similarity in discussion structure.",
                    created_at: "2024-01-15T11:20:00.000Z",
                    children: [],
                  },
                ],
              },
            ],
          },
          {
            id: 12345687,
            author: null,
            text: null,
            deleted: true,
            created_at: "2024-01-15T11:30:00.000Z",
            children: [
              {
                id: 12345688,
                author: "someone_else",
                text: "Replying to a deleted comment here - the context is lost but this reply remains.",
                created_at: "2024-01-15T11:35:00.000Z",
                children: [],
              },
            ],
          },
          {
            id: 12345689,
            author: "jacobian",
            text: "I love that this uses the Algolia API. That's the same API that powers the HN search, right? It's much more reliable than scraping.",
            created_at: "2024-01-15T12:00:00.000Z",
            children: [
              {
                id: 12345690,
                author: "pg",
                text: "Exactly! The official Firebase API is also an option but Algolia gives you the full thread structure in one request which is much more convenient.",
                created_at: "2024-01-15T12:05:00.000Z",
                children: [],
              },
              {
                id: 12345691,
                author: "simonw",
                text: "I built a similar tool a while back for exporting threads. The Algolia API is great but watch out for rate limits on very active threads.",
                created_at: "2024-01-15T12:10:00.000Z",
                children: [
                  {
                    id: 12345692,
                    author: "jacobian",
                    text: "Good point about rate limits. Have you found any workarounds?",
                    created_at: "2024-01-15T12:15:00.000Z",
                    children: [
                      {
                        id: 12345693,
                        author: "simonw",
                        text: "Caching helps a lot. I cache responses for a few minutes since HN comments don't change that frequently. Also, you can paginate through children if a thread is huge.",
                        created_at: "2024-01-15T12:20:00.000Z",
                        children: [
                          {
                            id: 12345694,
                            author: "jacobian",
                            text: "Makes sense. Thanks for the tips!",
                            created_at: "2024-01-15T12:25:00.000Z",
                            children: [],
                          },
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
          {
            id: 12345695,
            author: "luu",
            text: "This is a really long comment to test the truncation feature. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. And here's even more text to make sure we definitely exceed the 300 character limit for truncation testing purposes. The quick brown fox jumps over the lazy dog. Pack my box with five dozen liquor jugs.",
            created_at: "2024-01-15T13:00:00.000Z",
            children: [],
          },
          {
            id: 12345696,
            author: "rauchg",
            text: "Nice work! The search feature is particularly useful. I often want to find specific mentions in long threads.",
            created_at: "2024-01-15T14:00:00.000Z",
            children: [
              {
                id: 12345697,
                author: "gaearon",
                text: "Agreed, search is key. Would be cool if it could also search by author name.",
                created_at: "2024-01-15T14:05:00.000Z",
                children: [
                  {
                    id: 12345698,
                    author: "rauchg",
                    text: "Looks like there's already a checkbox for that! 'Include authors' in the search options.",
                    created_at: "2024-01-15T14:10:00.000Z",
                    children: [
                      {
                        id: 12345699,
                        author: "gaearon",
                        text: "Oh nice, I missed that. Very thorough!",
                        created_at: "2024-01-15T14:15:00.000Z",
                        children: [],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      };

      // Debug mock mode: switch to JSON tab and pre-populate with mock data
      if (isDebugMock) {
        console.log("üîß Debug mode enabled: mock data pre-populated");
        document.getElementById("debug-banner").style.display = "block";
        document.getElementById("debug-banner-text").textContent =
          "Mock data has been pre-populated in the Custom JSON tab.";
        switchTab("custom-json");
        document.getElementById("manual-json").value = JSON.stringify(
          MOCK_HN_RESPONSE,
          null,
          2
        );
      }
    </script>
    <!-- END MOCK DATA -->
  </body>
</html>
